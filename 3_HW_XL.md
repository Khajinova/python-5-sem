### Урок 3 - git + введение в ООП
---

1. Как расшифровывается СКВ (VCS) и зачем они нужны в больших проектах?
Это система контроля версий. В больших проектах нужны, чтобы видеть изменения кода. Можно увидеть, кто и когда что-то поменял.
Позволит удалить ненужные изменения и вернуться к предыдущим версиям кода. Так же СВК дает возможность совместной работе над кодом. Более того, есть резервное копирование,
поэтому код всегда будет в безопасности.
2. В чем отличия централизованных СКВ от децентрализованных?  
Централизованные СВК: Изменения кода хранятся на центральном сервере. Пользователи работают с локальной копией проекта, а затем отправляют изменения на центральный сервер.
и они обычно работают в одной ветке, а изменения должны быть утверждены администратором перед тем, как их можно будет добавить в основную версию. Тут достаточно сложно
создовать и объединять ветви, это может ограничивать параллельную работу над разными задачам. И основная проблема, если центральный сервер недоступен, то разработчики не могут работать над проектом. И при ошибках на сервере пользователи не смогут их достать.  
Пример Google docs  
Децентрализованные СКВ: Здесь у каждого разработчика есть полная история изменений проекта. Можно легко взаимодействовать друг с другом, обмениваясь изменениями кода. Свободная работа с ветвями. Это очень упрощает и ускоряет работу над проектами. Устойчивы к ошибкам, даже если один репозиторий недоступен,
другие остаются доступными.  
Пример Git
3. Что такое git и чем он отличается от GitHub?  
Git - это система управления версиями. GitHub - это платформа хостинга для проектов Git.
Git позволяет вам управлять версиями вашего проекта локально на вашем компьютере. GitHub обеспечивает облачное хранилище для ваших проектов Git и предоставляет дополнительные функции для совместной работы, где можно делиться своими проектами и изучать работы других ребят.
Git - это технология, а GitHub - это сервис.
4. В каких случаях имеет смысл создавать различные ветки проекта?  
Вообще новые ветки позволяют эффективно организовать работу над совместным проектом. Можно создовать ветки для каждой новой функции, чтобы не мешать основному коду и спокойно исправлять ошибки, чтобы другим пользователям было комфортно пользоваться основным проектом. Вообще можно создавать специальные ветки для исправления ошибок. Так же ветки для новых идей и технологий, чтобы не портить основной код. Удобно для совместной работы, разделили обязоности, каждый создал свою ветку и спокойно работает, не мешая другу.
А когда все закончили и протестировали, можно будет легко объединит все ветки в основной проект.  
5. В чем отличия merge и rebase? В чем преимущества и недостатки последнего из них?  
Merge (слияние): объединяет ветку с основной. Git создает новый коммит, содержащий изменения из обеих веток, и добавляет его в историю. В нем есть ссылки на два родительских коммита.  
Rebase (перебазирование): переносит коммиты из одной ветки на другую ветку. Он применяет изменения из одной ветки к другой, как будто они были сделаны последовательно. Rebase создает новые коммиты, которые содержат изменения из "перебазированной" ветки.
Преимущества: Чистая линейная история, в такой последовательности легче проследить, как изменения в одной ветке были перенесены в другую.
Недостатки: Rebase меняет историю коммитов, что может создать проблемы, если другие разработчики уже работали с этой веткой. 
6. Как расшифровывается ООП, в чем заключается идея объекта?
ООП расшифровывается как Объектно-ориентированное программирование. Идея объекта в ООП - это центральное понятие. Объект - это абстракция реального или воображаемого объекта, которая представляет собой сочетание данных (свойств) и действий (методов), которые работают с типом данных объекта.
Объекты можно реализовать через классы.
7. В чем опасность переменных класса?  
Возможны неконтролируемые изменения - Переменные класса доступны из любого места в коде, независимо от создания конкретного объекта, т.е любой метод или код может изменять их значения, без явного контроля со стороны объекта.
Переменные класса создают зависимость между различными частями кода. Изменение значения переменной класса может неожиданно повлиять на поведение других частей программы, которые ее используют
Переменная класса не копируется в каждый экземпляр класса, а существует в единственном экземпляре для всех объектов этого класса.
8. Какую роль играет ключевое слово self?  
Ключевое слово self в Python играет ключевую роль в объектно-ориентированном программировании (ООП). Оно позволяет нам  связывать  методы  класса  с  конкретными  экземплярами  этого  класса.
9. Как переменная __dict__ связана с остальными переменными класса? Что это говорит нам о природе объектов в Python?  
__dict__ - это скрытый атрибут: Он позволяет нам получить доступ к внутреннему словарю объекта. Этот словарь хранит все атрибуты объекта в виде ключ-значение пар, включая как атрибуты экземпляра, так и атрибуты класса. Таким образом, все объекты в Python реализованы через словари.  
10. В чем заключается основная идея инкапсуляции?  
Основная идея инкапсуляции в объектно-ориентированном программировании (ООП) заключается в сокрытии внутренней реализации объекта от внешнего мира, предоставляя доступ к его данным и функциональности только через определенные методы.
Внешний мир:  Это код, который использует объект.  
Внутренняя реализация:  Это код, который определяет, как работает объект, включая его данные (атрибуты) и методы.
Инкапсуляция  разделяет  роль  пользователя  (того,  кто  использует  объект)  и  реализатора  (того,  кто  создает  объект).  Пользователь  не  должен  знать  внутреннюю  реализацию  объекта  и  взаимодействует  с  ним  только  через  интерфейс  (публичные  методы). В  рамках  инкапсуляции  внутренние  данные  объекта  (переменные)  обычно  делаются  "приватными",  что  означает,  что  пользователь  не  может  получить  к  ним  прямой  доступ. 
В питоне инкапсуляция  реализуется  на  уровне  договоренностей  и  конвенций. "Приватность"  маркируется  использованием  одного  или  двух  символов  _  в  начале  имени  переменной  или  метода. 
В итоге это всё приводит к более простому и эффективному коду
  

     



 

 
 






   
