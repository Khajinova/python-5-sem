1. В чем основная идея полиморфизма? Как он реализуется в Python. Позволяет использовать код для работы с разными объектами  разных типов. В Python полиморфизм реализуется с помощью наследования и интерфейсов (протоколов).
Интерфейсы (протоколы) - это набор методов, которые должны быть реализованы в классах, реализующих этот протокол. в питоне реализация обычно уходит в соответствующий метод
2. Зачем переопределять метод __radd__() наравне с __add__()? Переопределение методов __add__() и __radd__() в Python необходимо для достижения симметричного поведения при сложении объектов. Это проверка, что правая структура может прибавлять себе левую. Тип что бы работала перестановка слагаемых
3. Как можно описать взаимоотношения родительского и дочернего классов?  
Можно описать как наследование. Дочерний класс наследует атрибуты и методы родительского класса, может расширять или изменять их поведение. Родительский класс представляет общие черты, а дочерний — добавляет специализированные или дополнительные функции.
4. Для чего используется ключевое слово super()? Используется в питоне для обращения к методам и атрибутам родительского класса из дочернего класса. Оно позволяет вызывать методы родительского класса, что упрощает наследование и переопределение методов.
5. Какую роль играет порядок классов предков при множественном наследовании? Определяет последовательность, в которой питон будет искать методы и атрибуты. Этот порядок описан в MRO. Если несколько родительских классов имеют методы с одинаковыми именами, используется метод, найденный первым в MRO, что предотвращает конфликты и обеспечивает предсказуемое поведение.
6. Зачем нужна обработка исключений? В каких случаях ее использование некорректно? Нужна для предотвращения аварийного завершения программы и корректной обработки ошибок. Неккоректно: когда ошибки можно предотвратить проверкой условий (например, перед делением проверять делитель).
7. Зачем в блоке try использовать раздел finally? Используется для выполнения кода, который должен выполняться в любом случае — независимо от возникновения исключения. Закрытие файлов
8. Что нужно сделать, чтобы реализовать свое собственное исключение? Необходимо создать новый класс, который наследует от встроенного класса Exception. После этого можно использовать это исключение в коде с помощью оператора raise
9. Чем итератор отличается от генератора? Итератор — объект с методами __iter__() и __next__(), позволяющий перебирать элементы. Генератор — упрощенный итератор, создаваемый с помощью функции с yield
10. В чем минусы декорирования функций? Можно частично потерять данные, могут замедлить выполнение функции
    
